<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>Eric S. Talbot</title>
        <link>http://ericstalbot.github.io/</link>
        <description></description>
        <language>en-us</language>
        <pubDate>Sat, 23 Apr 2016 00:00:00 -0600</pubDate>
        
        <item>
            <link>http://ericstalbot.github.io/2016/04/23/building_blocks_for_my_bike_ride_map.html</link>
            <guid>http://ericstalbot.github.io/2016/04/23/building_blocks_for_my_bike_ride_map.html</guid>
            <title><![CDATA[Building Blocks for a Web Map]]></title>
            <description><![CDATA[<h1>Building Blocks for a Web Map</h1>
<p>Here’s an outline of how I build the bike ride web map:</p>
<div class="section" id="the-back-end">
<h2>The back end</h2>
<ul class="simple">
<li>I started out with the Vermont roads geospatial data set from VCGI.</li>
<li>I processed the data using Python scripts.
A major part of the processing was to translate the data
into human-readable labels for road type and whether the
road is paved or not. Another part of the processing was
to assign an “A” node and a “B” node to each roadway segment.
This allows the segments to be connected together to
form a network.</li>
<li>Then I uploaded the processed data to CartoDB. This web service
layers over PostGIS and provides a SQL API to query the roadway segments data
It also provides an interface to style the data using CartoCSS and
a JavaScript library to create map layers
from the styled data for Leaflet.js.</li>
<li>The next step was to write a Python function for
getting the the shortest path along the network between
a pair of points. The function takes a pair of x,y coordinates;
queries the CartoDB API to get the roadway segments in the
neighborhood as GeoJson features;
constructs a NetworkX graph using the “anode”
and “bnode” attributes of the features; inserts nodes
for the starting and ending points; finds the shortest path
between the points; and then returns an array of x,y points
giving the shape of the path.</li>
<li>I then wrapped the shortest path function in a HTTP interface
using Flask. The inputs are passed as a HTTP GET parameter,
and the outputs are returned as JSON. I then deployed the Flask web application
on pythonanywhere.com.</li>
<li>The end result is a routing API that takes a series of waypoints
as a parameter and returns the shape of the path connecting those
points.</li>
</ul>
</div>
<div class="section" id="the-front-end">
<h2>The front end</h2>
<ul class="simple">
<li>I created a web page which features a Leaflet.js map,
and used the CartoDB functions to add my road data as the main layer.
I then added interactions using pure JavaScript to allow
creating and editing the way points, and connected this user interface
to the routing API using an asynchronous request.</li>
<li>I set up the Flask application on pythonanywhere.com
to serve the web page as a static
template.</li>
<li>The end result is a web application where users can create and
edit waypoints and then get the shape of the path connecting them.</li>
</ul>
</div>
<div class="section" id="links">
<h2>Links</h2>
<ul class="simple">
<li>the web application: <a class="reference external" href="http://ericstalbot.pythonanywhere.com/">http://ericstalbot.pythonanywhere.com/</a></li>
<li>project on github: <a class="reference external" href="https://github.com/ericstalbot/roadfollowing">https://github.com/ericstalbot/roadfollowing</a>
(includes the data processing scripts, path-finding function,
Flask application, and web page source.)</li>
<li>profile on CartoDB: <a class="reference external" href="https://ericstalbot.cartodb.com/me">https://ericstalbot.cartodb.com/me</a>
(includes links to the road data and map)</li>
<li>original road data: <a class="reference external" href="http://maps.vcgi.org/gisdata/vtrans/packaged_zips/TransRoad_RDS.zip">http://maps.vcgi.org/gisdata/vtrans/packaged_zips/TransRoad_RDS.zip</a></li>
</ul>
</div>
]]></description>
             <pubDate>Sat, 23 Apr 2016 00:00:00 -0600</pubDate>
        </item>
    
        <item>
            <link>http://ericstalbot.github.io/2016/04/21/why_another_web_map.html</link>
            <guid>http://ericstalbot.github.io/2016/04/21/why_another_web_map.html</guid>
            <title><![CDATA[Why Another Web Map?]]></title>
            <description><![CDATA[<h1>Why Another Web Map?</h1>
<p>I recently launched my new web map at <a class="reference external" href="http://ericstalbot.pythonanywhere.com/">http://ericstalbot.pythonanywhere.com/</a>.
I’m pretty excited about it, but why do we need another web map
when the internet already has so many very good ones?</p>
<p>I started working on the map back when I lived in Vermont, and
it’s original purpose was very simple: to help me plan
bike rides on the Green Mountain State’s beautiful back roads.
I had tried to use the internet’s existing maps, but they didn’t
work for me. So I decided to build my own map with a number
of improvements:</p>
<ul class="simple">
<li>My new map shows trails and class 4 roads, which are unmaintained
public right-of-way. They are usually unpassable to most vehicles
but they are fun to ride and provide important connections between
valleys.</li>
<li>You can zoom way out on my map, and the smaller, less important
roads never disappear. So you can zoom out far enough to plan
a longer ride, but still see all the tiny dirt roads that you
can piece together to make your ride fun.</li>
<li>The map does not have distracting features like hill shading.
The focus is on the roads, which makes it easy to
see how roads connect to each other and make
infinite possibilities for out-and-back and looping rides.</li>
<li>The router on the map has no concept of “best”, or “fastest”
path, so it does not force the path to follow the big
roads, which often have too much traffic. Instead, it
simply follows the least-distance path, which can produce
some fun rides and help you see possible paths that you’ve never
considered.</li>
</ul>
<p>Go ahead and try the map out. In the meantime, I’ll be working
on making it even better.</p>
]]></description>
             <pubDate>Thu, 21 Apr 2016 00:00:00 -0600</pubDate>
        </item>
    
        <item>
            <link>http://ericstalbot.github.io/2014/01/24/viewing_spatial_data_in_ipython.html</link>
            <guid>http://ericstalbot.github.io/2014/01/24/viewing_spatial_data_in_ipython.html</guid>
            <title><![CDATA[Viewing Spatial Data in IPython]]></title>
            <description><![CDATA[<h1>Viewing Spatial Data in IPython</h1>
<p>I do a lot of geospatial analysis for my work in transportation. My usual workflow
includes manipulating and analyzing data using IPython, and then viewing the
data by creating matplotlib plots, like this one:</p>
<blockquote>
<div><img alt="../../../_images/plot.png" src="http://ericstalbot.github.io/_images/plot.png"/>
</div></blockquote>
<p>However, I frequently have found myself writing data to disk so I could explore
it more interactively using QGIS. And more recently, I’ve been creating one-off
HTML documents to view my data in slippy maps. Which got me thinking - how could you
combine the great tools of Python and IPython with the ability to interactively
explore data like you do in a desktop GIS or a web map?</p>
<p>Well, it turned out to be a lot easier than I expected. IPython is already
set up to render objects as HTML. All you have to do is provide a <cite>_repr_html_</cite>
method which returns an HTML string. So I wrote a class that is initialized
with a mapping in geojson format, and that has a <cite>_repr_html_</cite> method that returns
an HTML web map powered by Leaflet’s TileLayer and GeoJSON objects. So after
about 30 minutes and 60 lines (including a HTML template) this is what I had:</p>
<blockquote>
<div><img alt="../../../_images/webmap.png" src="http://ericstalbot.github.io/_images/webmap.png"/>
</div></blockquote>
<p>Check out <a class="reference external" href="https://gist.github.com/ericstalbot/8605945">what</a> on github.</p>
]]></description>
             <pubDate>Fri, 24 Jan 2014 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://ericstalbot.github.io/2013/12/20/spatialdigraph.html</link>
            <guid>http://ericstalbot.github.io/2013/12/20/spatialdigraph.html</guid>
            <title><![CDATA[spatialdigraph]]></title>
            <description><![CDATA[<h1>spatialdigraph</h1>
<p>NetworkX is a great Python package for working with networks. It sits right next to NumPy, matplotlib, and Shapely in my everyday transportation analysis toolbox. However, I’ve often wished that Networkx graphs had spatial capabilities. So that’s why I created <a class="reference external" href="https://github.com/ericstalbot/spatialdigraph">spatialdigraph</a>. Here’s how it works:</p>
<p>First, load a SpatialDiGraph of a highway interchange in New Hampshire:</p>
<div class="highlight-default"><div class="highlight"><pre><span/><span class="n">g</span> <span class="o">=</span> <span class="n">cPickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s1">'mygraph.pickle'</span><span class="p">))</span>
</pre></div>
</div>
<p>This graph is in WGS84, so let’s transform to UTM for better drawing:</p>
<div class="highlight-default"><div class="highlight"><pre><span/><span class="n">g</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">fiona</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">from_epsg</span><span class="p">(</span><span class="mi">32617</span><span class="p">))</span>
</pre></div>
</div>
<p>And now we can draw the graph:</p>
<div class="highlight-default"><div class="highlight"><pre><span/><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">node_args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'s'</span><span class="p">:</span><span class="mi">0</span><span class="p">},</span> <span class="n">edge_args</span> <span class="o">=</span> <span class="p">{</span><span class="s1">'c'</span><span class="p">:</span><span class="s1">'0.5'</span><span class="p">})</span>
</pre></div>
</div>
<p>The SpatialDiGraph is a networkx.DiGraph subclass, so we have access to lots of useful
methods from NetworkX. For example, we can get a shortest path on the network:</p>
<div class="highlight-default"><div class="highlight"><pre><span/><span class="n">origin</span><span class="p">,</span> <span class="n">destination</span> <span class="o">=</span> <span class="s1">'194912632'</span><span class="p">,</span> <span class="s1">'195049052'</span>
<span class="n">path</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
</pre></div>
</div>
<p>Then with the added functionality that the SpatialDiGraph provides we can draw the path:</p>
<div class="highlight-default"><div class="highlight"><pre><span/><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">xy</span><span class="p">(</span><span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="s1">'b'</span><span class="p">,</span> <span class="n">lw</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>And just to make it pretty, let’s also highlight the origin and destination nodes:</p>
<div class="highlight-default"><div class="highlight"><pre><span/><span class="n">scatter_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">zorder</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="s1">'orange'</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span> <span class="n">edgecolor</span> <span class="o">=</span> <span class="s1">'none'</span><span class="p">)</span>

<span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">xy</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">scatter_args</span><span class="p">)</span>

<span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">xy</span><span class="p">(</span><span class="n">destination</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">scatter_args</span><span class="p">)</span>
</pre></div>
</div>
<p>Here’s the final result:</p>
<a class="reference internal image-reference" href="http://ericstalbot.github.io/_images/interchange.png"><img alt="../../../_images/interchange.png" src="http://ericstalbot.github.io/_images/interchange.png" style="width: 600px;"/></a>
<p>spatialdigraph is still a work in progress, but feel free to <a class="reference external" href="https://github.com/ericstalbot/spatialdigraph">check it out</a> on GitHub.</p>
]]></description>
             <pubDate>Fri, 20 Dec 2013 00:00:00 -0700</pubDate>
        </item>
    
        <item>
            <link>http://ericstalbot.github.io/2013/12/06/bluetooth_vehicle_tracking___correcting_short_trip_bias.html</link>
            <guid>http://ericstalbot.github.io/2013/12/06/bluetooth_vehicle_tracking___correcting_short_trip_bias.html</guid>
            <title><![CDATA[Bluetooth Vehicle Tracking:  Correcting Short Trip Bias]]></title>
            <description><![CDATA[<h1>Bluetooth Vehicle Tracking:  Correcting Short Trip Bias</h1>
<p>A new thing in transportation analysis is the use of arrays of Bluetooth detectors
to track cars. The detectors work by recording the MAC IDs of wireless devices inside cars that
pass nearby. By linking together multiple detections of the same MAC ID across different detectors,
you can make a pretty good guess at the starting point, ending point, and route taken for a trip.</p>
<p>There is one problem, however. Detectors can “miss” cars: even though a car has a wireless device
inside, and it passes near a detector, the detector may fail to detect it. This has the effect of
making some trips appear shorter than they really are. Take for example a car that passes near detectors
1, 2, and 3. If detector 1 misses the car, the trip will appear to have passed by only
detectors 2 and 3.</p>
<p>To fix this problem, I’ve proposed an estimation method that explicitly accounts for missed
detections. My tests show improvements over a naive method that ignores missed detections:</p>
<a class="reference internal image-reference" href="http://ericstalbot.github.io/_images/naive.png"><img alt="../../../_images/naive.png" src="http://ericstalbot.github.io/_images/naive.png" style="width: 600px;"/></a>
<p>See my <a class="reference external" href="http://ericstalbot.github.io/bluetooth/TalbotBluetooth.pdf">paper</a> and IPython <a class="reference external" href="http://ericstalbot.github.io/bluetooth/RouteFlowsRoadsideDetectors-v2.html">notebook</a> for details on the estimation method.</p>
]]></description>
             <pubDate>Fri, 06 Dec 2013 00:00:00 -0700</pubDate>
        </item>
    
    </channel>
</rss>