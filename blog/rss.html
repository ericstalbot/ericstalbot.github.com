<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0">
    <channel>
        <title>Eric S. Talbot</title>
        <link>http://ericstalbot.github.io/</link>
        <description></description>
        <language>en-us</language>
        <pubDate>Fri, 24 Jan 2014 00:00:00 -0500</pubDate>
        
        <item>
            <link>http://ericstalbot.github.io/2014/01/24/viewing_spatial_data_in_ipython.html</link>
            <guid>http://ericstalbot.github.io/2014/01/24/viewing_spatial_data_in_ipython.html</guid>
            <title><![CDATA[Viewing Spatial Data in IPython]]></title>
            <description><![CDATA[<div class="section" id="viewing-spatial-data-in-ipython">
<h1>Viewing Spatial Data in IPython</h1>
<p>I do a lot of geospatial analysis for my work in transportation. My usual workflow
includes manipulating and analyzing data using IPython, and then viewing the
data by creating matplotlib plots, like this one:</p>
<blockquote>
<div><img alt="../../../_images/plot.png" src="http://ericstalbot.github.io/_images/plot.png"/>
</div></blockquote>
<p>However, I frequently have found myself writing data to disk so I could explore
it more interactively using QGIS. And more recently, I’ve been creating one-off
HTML documents to view my data in slippy maps. Which got me thinking - how could you
combine the great tools of Python and IPython with the ability to interactively
explore data like you do in a desktop GIS or a web map?</p>
<p>Well, it turned out to be a lot easier than I expected. IPython is already
set up to render objects as HTML. All you have to do is provide a <cite>_repr_html_</cite>
method which returns an HTML string. So I wrote a class that is initialized
with a mapping in geojson format, and that has a <cite>_repr_html_</cite> method that returns
an HTML web map powered by Leaflet’s TileLayer and GeoJSON objects. So after
about 30 minutes and 60 lines (including a HTML template) this is what I had:</p>
<blockquote>
<div><img alt="../../../_images/webmap.png" src="http://ericstalbot.github.io/_images/webmap.png"/>
</div></blockquote>
<p>Check out <a class="reference external" href="https://gist.github.com/ericstalbot/8605945">what</a> on github.</p>
</div>]]></description>
             <pubDate>Fri, 24 Jan 2014 00:00:00 -0500</pubDate>
        </item>
    
        <item>
            <link>http://ericstalbot.github.io/2013/12/20/spatialdigraph.html</link>
            <guid>http://ericstalbot.github.io/2013/12/20/spatialdigraph.html</guid>
            <title><![CDATA[spatialdigraph]]></title>
            <description><![CDATA[<div class="section" id="spatialdigraph">
<h1>spatialdigraph</h1>
<p>NetworkX is a great Python package for working with networks. It sits right next to NumPy, matplotlib, and Shapely in my everyday transportation analysis toolbox. However, I’ve often wished that Networkx graphs had spatial capabilities. So that’s why I created <a class="reference external" href="https://github.com/ericstalbot/spatialdigraph">spatialdigraph</a>. Here’s how it works:</p>
<p>First, load a SpatialDiGraph of a highway interchange in New Hampshire:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">g</span> <span class="o">=</span> <span class="n">cPickle</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="nb">open</span><span class="p">(</span><span class="s">'mygraph.pickle'</span><span class="p">))</span>
</pre></div>
</div>
<p>This graph is in WGS84, so let’s transform to UTM for better drawing:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">g</span><span class="o">.</span><span class="n">transform</span><span class="p">(</span><span class="n">fiona</span><span class="o">.</span><span class="n">crs</span><span class="o">.</span><span class="n">from_epsg</span><span class="p">(</span><span class="mi">32617</span><span class="p">))</span>
</pre></div>
</div>
<p>And now we can draw the graph:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">fig</span><span class="p">,</span> <span class="n">ax</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">subplots</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="n">g</span><span class="o">.</span><span class="n">draw</span><span class="p">(</span><span class="n">ax</span><span class="p">,</span> <span class="n">node_args</span> <span class="o">=</span> <span class="p">{</span><span class="s">'s'</span><span class="p">:</span><span class="mi">0</span><span class="p">},</span> <span class="n">edge_args</span> <span class="o">=</span> <span class="p">{</span><span class="s">'c'</span><span class="p">:</span><span class="s">'0.5'</span><span class="p">})</span>
</pre></div>
</div>
<p>The SpatialDiGraph is a networkx.DiGraph subclass, so we have access to lots of useful
methods from NetworkX. For example, we can get a shortest path on the network:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">origin</span><span class="p">,</span> <span class="n">destination</span> <span class="o">=</span> <span class="s">'194912632'</span><span class="p">,</span> <span class="s">'195049052'</span>
<span class="n">path</span> <span class="o">=</span> <span class="n">networkx</span><span class="o">.</span><span class="n">shortest_path</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">destination</span><span class="p">)</span>
</pre></div>
</div>
<p>Then with the added functionality that the SpatialDiGraph provides we can draw the path:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">xy</span><span class="p">(</span><span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="s">'b'</span><span class="p">,</span> <span class="n">lw</span> <span class="o">=</span> <span class="mi">4</span><span class="p">)</span>
</pre></div>
</div>
<p>And just to make it pretty, let’s also highlight the origin and destination nodes:</p>
<div class="highlight-python"><div class="highlight"><pre><span class="n">scatter_args</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">zorder</span> <span class="o">=</span> <span class="mi">10</span><span class="p">,</span> <span class="n">c</span> <span class="o">=</span> <span class="s">'orange'</span><span class="p">,</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">80</span><span class="p">,</span> <span class="n">edgecolor</span> <span class="o">=</span> <span class="s">'none'</span><span class="p">)</span>

<span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">xy</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">scatter_args</span><span class="p">)</span>

<span class="n">x</span><span class="p">,</span><span class="n">y</span> <span class="o">=</span> <span class="n">g</span><span class="o">.</span><span class="n">xy</span><span class="p">(</span><span class="n">destination</span><span class="p">)</span>
<span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">,</span> <span class="o">**</span><span class="n">scatter_args</span><span class="p">)</span>
</pre></div>
</div>
<p>Here’s the final result:</p>
<a class="reference internal image-reference" href="http://ericstalbot.github.io/_images/interchange.png"><img alt="../../../_images/interchange.png" src="http://ericstalbot.github.io/_images/interchange.png" style="width: 600px;"/></a>
<p>spatialdigraph is still a work in progress, but feel free to <a class="reference external" href="https://github.com/ericstalbot/spatialdigraph">check it out</a> on GitHub.</p>
</div>]]></description>
             <pubDate>Fri, 20 Dec 2013 00:00:00 -0500</pubDate>
        </item>
    
        <item>
            <link>http://ericstalbot.github.io/2013/12/06/bluetooth_vehicle_tracking___correcting_short_trip_bias.html</link>
            <guid>http://ericstalbot.github.io/2013/12/06/bluetooth_vehicle_tracking___correcting_short_trip_bias.html</guid>
            <title><![CDATA[Bluetooth Vehicle Tracking:  Correcting Short Trip Bias]]></title>
            <description><![CDATA[<div class="section" id="bluetooth-vehicle-tracking-correcting-short-trip-bias">
<h1>Bluetooth Vehicle Tracking:  Correcting Short Trip Bias</h1>
<p>A new thing in transportation analysis is the use of arrays of Bluetooth detectors
to track cars. The detectors work by recording the MAC IDs of wireless devices inside cars that
pass nearby. By linking together multiple detections of the same MAC ID across different detectors,
you can make a pretty good guess at the starting point, ending point, and route taken for a trip.</p>
<p>There is one problem, however. Detectors can “miss” cars: even though a car has a wireless device
inside, and it passes near a detector, the detector may fail to detect it. This has the effect of
making some trips appear shorter than they really are. Take for example a car that passes near detectors
1, 2, and 3. If detector 1 misses the car, the trip will appear to have passed by only
detectors 2 and 3.</p>
<p>To fix this problem, I’ve proposed an estimation method that explicitly accounts for missed
detections. My tests show improvements over a naive method that ignores missed detections:</p>
<a class="reference internal image-reference" href="http://ericstalbot.github.io/_images/naive.png"><img alt="../../../_images/naive.png" src="http://ericstalbot.github.io/_images/naive.png" style="width: 600px;"/></a>
<p>See my <a class="reference external" href="http://ericstalbot.github.io/bluetooth/TalbotBluetooth.pdf">paper</a> and IPython <a class="reference external" href="http://ericstalbot.github.io/bluetooth/RouteFlowsRoadsideDetectors-v2.html">notebook</a> for details on the estimation method.</p>
</div>]]></description>
             <pubDate>Fri, 06 Dec 2013 00:00:00 -0500</pubDate>
        </item>
    
    </channel>
</rss>